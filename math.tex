% !TEX program = pdflatex
\documentclass[11pt]{article}
\usepackage{amsmath, amssymb}
\usepackage[margin=1in]{geometry}
\usepackage{minted}  % better code highlighting; requires -shell-escape
\setlength{\parskip}{0.35em}
\setlength{\parindent}{0pt}

\begin{document}
\title{Canonical Contract: Terse Setup and Vectorized Formulas}
\date{\vspace{-1ex}}
\maketitle

\textbf{Density.} Let $f(y,a) = f(y \mid a)$ be the outcome density for action $a$.  
Define $f0(y) := f(y \mid a_0)$ and the score at $a_0$:
\[
s0(y) = \frac{\partial_a f(y \mid a)\big|_{a=a_0}}{f0(y)}.
\]

\textbf{Canonical contract.} Let $v = g(z)$ with
\[
z(y) = \lambda + \mu\, s0(y) + \sum_{i=1}^{m} \hat\mu_i \Big( 1 - \frac{f(y \mid \hat a_i)}{f0(y)} \Big),
\qquad m = \#\{\hat a_i\}.
\]
$g(\cdot)$ is a fixed link (pointwise). Wages: $w = k(v)$.

\textbf{Primitives.} For action $a$,
\[
U(v,a) = \int v(y)\, f(y \mid a)\, dy - C(a), \quad C'(a)\ \text{exists}, \quad U0 := U(v,a_0).
\]

\textbf{Constraint maps (functions of $\theta = (\lambda,\mu,\hat\mu)$).}
\[
IR(\theta) := \bar U - U0(\theta) \;\le\; 0,\quad
IC_i(\theta) := U(v(\theta),\hat a_i) - U0(\theta) \;\le\; 0,\quad
FOC(\theta) := \int v(y;\theta)\, s0(y)\, f0(y)\, dy - C'(a_0) = 0.
\]

\textbf{Expected wage at $a_0$.}
\[
\mathbb{E}[w] = \int k(v(y;\theta))\, f0(y)\, dy.
\]

\hrulefill

\textbf{Vectorized (Python-style) notation.}

Cached values:
\[
wf0 = w * f0, \qquad wf0s0 = wf0 * s0, \qquad R = 1 - D/f0[:,None].
\]

Contract:
\[
z = \lambda + \mu\, s0 + R\,\hat\mu, \quad v = g(z).
\]

Constraints:
\[
U0 = (wf0) @ v - C(a0), \qquad
FOC = (wf0s0) @ v - C'(a0),
\]
\[
Uhat = (w[:,None] * D)^\top @ v - C(\hat a), \quad
IC = Uhat - U0, \quad IR = \bar U - U0.
\]

Expected wage:
\[
\mathbb{E}[w] = (wf0) @ k(v).
\]

Dual-like scalarization:
\[
g_{\text{dual}}(\theta) = \mathbb{E}[w] + \lambda \cdot IR - \mu \cdot FOC + \hat\mu^\top IC,
\]
\[
\nabla g_{\text{dual}}(\theta) = (IR,\; -FOC,\; IC).
\]

\hrulefill

\section*{Reference Python Implementation}

\begin{minted}[fontsize=\small, linenos, breaklines, frame=lines]{python}
# ---------- Cached values ----------
def make_cache(w, f0, s0, D, g, k, C, Cprime, Ubar, a0, a_hat):
    wf0   = w * f0
    wf0s0 = wf0 * s0
    R     = 1.0 - D / f0[:,None]
    return {
        "w": w, "f0": f0, "s0": s0, "D": D, "R": R,
        "wf0": wf0, "wf0s0": wf0s0,
        "g": g, "k": k, "C": C, "Cprime": Cprime,
        "Ubar": Ubar, "a0": a0, "a_hat": a_hat
    }

# ---------- Canonical contract ----------
def canonical_contract(multipliers, cache):
    lam, mu, mu_hat = multipliers
    z = lam + mu * cache["s0"] + cache["R"] @ mu_hat  # lambda broadcast
    v = cache["g"](z)
    return {"z": z, "v": v}

# ---------- Constraints ----------
def constraints(v, cache):
    wf0, wf0s0 = cache["wf0"], cache["wf0s0"]
    w, D = cache["w"], cache["D"]
    C, Cprime = cache["C"], cache["Cprime"]
    a0, Ubar = cache["a0"], cache["Ubar"]
    k = cache["k"]

    U0  = wf0 @ v - C(a0)
    FOC = wf0s0 @ v - Cprime(a0)
    Uhat = (w[:,None] * D).T @ v - C(cache["a_hat"])
    IC = Uhat - U0
    IR = Ubar - U0
    Ewage = wf0 @ k(v)

    return {"U0": U0, "IR": IR, "FOC": FOC,
            "Uhat": Uhat, "IC": IC, "Ewage": Ewage}

# ---------- Objective + gradient ----------
def objective_with_grad(multipliers, constraints_dict, cache):
    lam, mu, mu_hat = multipliers
    IR  = constraints_dict["IR"]
    FOC = constraints_dict["FOC"]
    IC  = constraints_dict["IC"]
    Ewage = constraints_dict["Ewage"]

    g_dual = Ewage + lam * IR - mu * FOC + mu_hat @ IC
    grad = (IR, -FOC, IC)
    return g_dual, grad
\end{minted}

\end{document}
